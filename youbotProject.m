function youbotProject()
    clc, clear all, close all

    run('C:/trs/matlab/startup_robot.m')
    
    
    %% Parameters
    use_getPosition = true;
    
    % The points x, y will be the optimal path points generated by the dstar 
    % First points by default. If it works, we will Dstar after.
    x=-3;
    y=-3;
    
    target=[x,y]; % target that the youbot will try to follow

    %% Initiate the connection to the simulator. 
    disp('Program started');
    
    vrep = remApi('remoteApi');
    vrep.simxFinish(-1);
    id = vrep.simxStart('127.0.0.1', 19997, true, true, 2000, 5);
    
    if id < 0
        disp('Failed connecting to remote API server. Exiting.');
        vrep.delete();
        return;
    end
    fprintf('Connection %d to remote API server open.\n', id);
    
    % Make sure to close the connection whenever the script is interrupted.
    cleanupObj = onCleanup(@() cleanup_vrep(vrep, id));
    
    vrep.simxStartSimulation(id, vrep.simx_opmode_oneshot_wait);
    
    % Retrieve all handles, and stream arm and wheel joints, the robot's pose, the Hokuyo, and the arm tip pose.
    h = youbot_init(vrep, id);
    h = youbot_hokuyo_init(vrep, h);
    
    pause(.2);

    %% Youbot constants
    % The time step the simulator is using (your code should run close to it). 
    timestep = .05;
    % Parameters for controlling the youBot's wheels: at each iteration, those values will be set for the wheels. 
    % They are adapted at each iteration by the code. 
    forwBackVel = 0; % Move straight ahead. 
    rightVel = 0; % Go sideways. 
    rotateRightVel = 0; % Rotate. 
    prevOrientation = 0; % Previous angle to goal (easy way to have a condition on the robot's angular speed). 
    prevPosition = 0; % Previous distance to goal (easy way to have a condition on the robot's speed).
    
    
    % Youbot's map
    map = OccupancyMap([201 201], 0.25);
    center = round( (size(map.Map) + 1) /2 );
    
    dstar = youbotDstar(zeros(size(map.Map)), 'quiet');
    
    
    % Youbot initial position
    [res, originPos] = vrep.simxGetObjectPosition(id, h.ref, -1, vrep.simx_opmode_buffer);
    vrchk(vrep, res, true);
    prevPosition = originPos(1:2);
    [res, originEuler] = vrep.simxGetObjectOrientation(id, h.ref, -1, vrep.simx_opmode_buffer);
    vrchk(vrep, res, true);
    prevOrientation = originEuler(3);
    
    % Target position
    %dstar.plan(round(( target-originPos(1:2) )/map.MapRes) + center);
    
    
    % Voir comment l'enlever
    [X, Y] = meshgrid(-5:map.MapRes:5, -5.5:map.MapRes:2.5);
    
    
    % Finite State Machine first state
    fsm = 'rotate';
    
    %% Start
    disp('Enter loop')
    while true
        start_loop = tic;
        
        if vrep.simxGetConnectionId(id) == -1
            error('Lost connection to remote API.');
        end
        
        % Get the position and the orientation of the robot. 
        [res, youbotPos] = vrep.simxGetObjectPosition(id, h.ref, -1, vrep.simx_opmode_buffer);
        vrchk(vrep, res, true);
        [res, youbotEuler] = vrep.simxGetObjectOrientation(id, h.ref, -1, vrep.simx_opmode_buffer);
        vrchk(vrep, res, true);
        
        
        %% Finite State Machine
       
            % Get sensor infos
            [pts, contacts] = youbot_hokuyo(vrep, h, vrep.simx_opmode_buffer);
            in = inpolygon(X, Y,...
                [h.hokuyo1Pos(1), pts(1, :), h.hokuyo2Pos(1)],...
                [h.hokuyo1Pos(2), pts(2, :), h.hokuyo2Pos(2)]);
            
            % Retrieve location information
            x_pts = youbotPos(1) - originPos(1) + X(in)*cos(youbotEuler(3)) - Y(in)*sin(youbotEuler(3));
            x_contact = youbotPos(1) - originPos(1) + pts(1, contacts)*cos(youbotEuler(3)) - pts(2, contacts)*sin(youbotEuler(3));

            y_pts = youbotPos(2) - originPos(2) + Y(in)*cos(youbotEuler(3)) + X(in)*sin(youbotEuler(3));
            y_contact = youbotPos(2) - originPos(2) + pts(2, contacts)*cos(youbotEuler(3)) + pts(1, contacts)*sin(youbotEuler(3));

            map.addPoints(-round(y_pts/map.MapRes) + center(1), round(x_pts/map.MapRes) + center(2), map.Free);
            map.addPoints(-round(y_contact/map.MapRes) + center(1), round(x_contact/map.MapRes) + center(2), map.Wall);
            
            currentPosIndex = [youbotPos(1) - originPos(1) + center(1)*map.MapRes,-(youbotPos(2) - originPos(2)) + center(2)*map.MapRes];
            

        if youbotPos(1)>x && youbotPos(2)<y
            angl=atan((y-youbotPos(2))/(x-youbotPos(1)))-pi/2;
        elseif  youbotPos(1)>x && youbotPos(2)>y
            angl=-atan((y-youbotPos(2))/(x-youbotPos(1)));
        elseif youbotPos(1)<x  && youbotPos(2)<y
            angl=atan((y-youbotPos(2))/(x-youbotPos(1)))+pi/2;
        elseif youbotPos(1)<x && youbotPos(2)>y
            -atan((y-youbotPos(2))/(x-youbotPos(1)));
        end
            
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        if strcmp(fsm, 'rotate')
            %% First, rotate the robot to go to one table.             
            % The rotation velocity depends on the difference between the current angle and the target. 
            rotateRightVel = angdiff(angl, youbotEuler(3))/2;
            
            % When the rotation is done (with a sufficiently high precision), move on to the next state. 
            if (abs(angdiff(angl, youbotEuler(3))) < .1 / 180 * pi) && ...
                    (abs(angdiff(prevOrientation, youbotEuler(3))) < .01 / 180 * pi)
                rotateRightVel = 0;
                fsm = 'driveToTarget';
            end
            
            prevOrientation = youbotEuler(3);
            
        elseif strcmp(fsm, 'driveToTarget')
            
            forwBackVel = (target(1)-youbotPos(1));%pos(2)-youbotPos(2);
            % If the robot is sufficiently close and its speed is
            % sufficiently low, stop it and compute new target
            norm(youbotPos(1:2) - target)
            if (norm(youbotPos(1:2) - target) < 0.5) && (norm(youbotPos(1:2) - prevPosition) < 0.5)
                forwBackVel = 0;
            end
        end

            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Previous position and orientation
        prevPosition = youbotPos(1:2);
        prevOrientation = youbotEuler(3);
        h = youbot_drive(vrep, h, forwBackVel, rightVel, rotateRightVel);
        figure(1)
        map.plot()
        hold on
        scatter(currentPosIndex(1),currentPosIndex(2), '*', 'r')
        
        %% Calculation time control
        ellapsed = toc(start_loop);
        remaining = timestep - ellapsed;
        if remaining > 0
            pause(min(remaining, .01));
        end
    end
    end
